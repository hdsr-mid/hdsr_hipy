{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inleiding aanpassingen grondwatermodel Hydromedah","text":"<p>HDSR heeft gevraagd om het Hydromedah grondwatermodel ten behoeve van de studie \"Gebiedsdekkende debietstatistieken ten behoeve van TEO\"  als volgt aan te passen:</p> <ul> <li> <p>De deklaagweerstand van Hydromedah vervangen door de LHM deklaagweerstand</p> </li> <li> <p>De peilen van Hydromedah aanpassen op basis van de nieuwe peilenkaart</p> </li> </ul> <p>Deze aanpassingen hebben we inzichtelijk gemaakt door het vervaardigen van een python notebook, zie paragraaf: \"Python-notebook\".  Hierin kunt stapsgewijs de aanpassing van het Hydromedah model volgen.</p> <p>Vervolgens vindt u in de paragraaf \"Resultaat\" de effecten van de aanpassingen van de nieuwe waterlooppeilen en de deklaagweerstand  op de grondwaterstand.</p>"},{"location":"debietstatistieken/","title":"Debietstatistieken ten behoeve van thermische energie uit oppervlaktewater","text":"<p>HDSR Hydrologische informatieproducten - debietstatistiek</p> <p>Ten behoeve van het project 'Debietstatistieken ten behoeve van thermische energie uit oppervlaktewater' is HDSRHIPY uitgebreid met de volgende features:</p> <ul> <li>Conversie van laterale afvoer naar een SOBEK LATERAL.DAT-bestand</li> <li>Functie die statistieken berekend voor een op te geven periode in het jaar op basis van Sobek resultaten</li> </ul> <p></p>"},{"location":"debietstatistieken/#conversie-van-laterale-afvoer-naar-een-sobek-lateraldat-bestand","title":"Conversie van laterale afvoer naar een SOBEK LATERAL.DAT-bestand","text":"<p>Uit de HYDROMEDAH run komt een CSV-bestand met de afwateringseenheden als kolommen en de tijdtappen als rijen. Deze informatie gebruiken we om een LATERAL.DAT te vullen voor Sobek. Hiervoor is de volgende informatie nodig: - een 'leeg' LATERAL.DAT bestand zonder tijdreeksen, maar met de juiste ID's van de lateralen (meegeleverd in de 'templates'-map); - GIS-bestanden die zijn geexporteerd uit SOBEK (3b_nod.shp en 3b_link.shp); - een koppeltabel tussen Hydromedah-SWNR-units en SOBEK-IDS van afwateringseenheden,.</p> <p>Vervolgens wordt voor elke lateral in Sobek de juiste kolom opgezocht in de CSV en wordt de reeks in het juiste format geschreven.</p> <p>Het kan voorkomen dat numerieke problemen optreden. Het is daarom mogelijk een dictionary mee te geven met een koppeling tussen reach-segmenten en lateralen. Deze zijn in GIS viseel gekoppeld en via de volgende stappen tot stand gekomen: - uitlezen FLOWANAL.HIS en bepalen op welke reach-segmenten de meeste iteraties veroorzaken; - in GIS uitzoeken welke lateralen daar net boventrooms van of op liggen.  Op alle lateralen die voorkomen in de dictionary wordt een anti-droogvaldebiet van 0.01 m3/s toegepast. De LATERAL.DAT is vervolgens gebruikt om de periode in SOBEK door te rekenen. Dit is niet opgenomen in HDSRHIPY omdat het te tijdrovend is.</p> <p>Als voorbeeld: de dict \"{}'H013921_1':['PG0599-1','PG0034-1','PG2177-1']}\" geeft aan dat aan reach 'H013921_1' drie lateralen gekoppeld zijn: PG0599-1, PG0034-1, en PG2177-1.</p> <p></p>"},{"location":"debietstatistieken/#functie-die-statistieken-bereket-voor-een-op-te-geven-periode-in-het-jaar-op-basis-van-sobek-resultaten","title":"Functie die statistieken bereket voor een op te geven periode in het jaar op basis van Sobek resultaten","text":"<p>Deze functie is inbegrepen in hdsrhipy en is een verkorte weergave van het eerder opgeleverde notebook 'debietstatistieken.ipynb'. Dat notebook is ook nu weer inbegrepen.</p> <p>In hdsrhipy moet eerst een 'flowstats' object worden aangemaakt. </p> <pre><code>flowstats = FlowStats(sobek_path=hisfiles, template_path=template_path, export_path=os.path.join(export_path, 'flowstats.shp'))\n</code></pre> <p>Hierbij is: - sobek_path: het pad naar de Sobek uitvoer, tot en met de .lit-map; - template_path: de plek waar de shape met reachsegmenten, geexporteerd uit Sobek, staat; - export path: de plek waar de resulterende shapefile wordt geschreven.</p> <p>Vervolgens worden de statistieken uitgerekend met de functie \"get_flowstats()\": </p> <pre><code>flowstats.get_flowstats(cases2join=cases, period=period, overschrijdingsduur_van_debiet=overschrijdingsduur_van_debiet, relatieve_overschrijdingsduur_van_debiet=relatieve_overschrijdingsduur_van_debiet,debiet_bij_tijdpercentiel=debiet_bij_tijdpercentiel)\n</code></pre> <p>waarbij \"cases\" de lijst van SObek-cases is waarvan de HIS-uitvoer moet worden samengevoegd. De andere argumenten geven de periode waarover statistieken worden uitgerekend en de parameters ervan:</p> <pre><code># maanden in het jaar om statistiek over te berekenen. De maand- en dag van deze periode wordt gebruikt om te bepalen of de dag moet worden meegenomen\nperiod = pd.date_range(start=pd.Timestamp('1900-05-15'),end=pd.Timestamp('1900-09-15'), freq='D')\n\n# de 'name' wordt gebruikt als kolom in de shapefile, de waarde is het debiet (m3/s) om te bepalen hoe vaak het wordt overschreden. Het resultaat is het aantal dagen.\noverschrijdingsduur_van_debiet = {'name': 'Ex5-9_005',  'value': 0.05}\n# Idem, maar nu is het resultaat de fractie van de tijd dat de waarde wordt overschreden\nrelatieve_overschrijdingsduur_van_debiet = {'name': 'REx5-9_005',  'value': 0.05}\n# en dit geeft het debiet dat x % van de tijd wordt overschreden\ndebiet_bij_tijdpercentiel = {'name': 'Q5-9_80%',  'value': 0.8}\n</code></pre>"},{"location":"resultaat_hydromedah/","title":"Resultaten Hydromedah model","text":"<p>De resultaten zijn gepresenteerd aan de hand van de volgende paragrafen: 1 Reproductie originele run 2 Effect aanpassing deklaagweerstand 3 Effect aanpassing peilen 4 Effect aanpassing peilen en deklaagweerstand 5 Conclusies en aanbevelingen  </p>"},{"location":"resultaat_hydromedah/#1-reproductie-originele-run","title":"1 Reproductie originele run","text":""},{"location":"resultaat_hydromedah/#11-vragen","title":"1.1 Vragen","text":"<p>In december 2021 is met hdsrhipy een originele run gedraaid met Hydromedah. Hiervan zijn de resultaten opgenomen in de rapportage. Wij proberen deze originele run te reproduceren en stellen de volgende vragen:  </p> <ol> <li>Is de reproductie identiek aan de resultaten van 2021? Nee, dan gaan we naar vragen 2 en 3  </li> <li>Zijn de verschillen te verklaren?  </li> <li>Levert de reproductie betere resultaten?   </li> </ol>"},{"location":"resultaat_hydromedah/#_1","title":"Resultaat Hydromedah","text":""},{"location":"resultaat_hydromedah/#vraag-1-is-de-reproductie-identiek-aan-de-resultaten-van-de-2021","title":"Vraag 1 Is de reproductie identiek aan de resultaten van de 2021?","text":"<p>De resultaten van de originele run verschillen met de originele run uit 2021:  -  Blauw: Grondwaterstand is hoger dan in 2021 -  Rood:  Grondwaterstand is lager dan in 2021  </p> <p></p>"},{"location":"resultaat_hydromedah/#vraag-2-zijn-de-verschillen-te-verklaren","title":"Vraag 2 Zijn de verschillen te verklaren?","text":"<p>We weten vooralsnog niet waardoor deze verschillen ontstaan. We hebben de volgende vragen beantwoord om een verklaring te vinden:</p> <ul> <li>Is er een ander Hydromedah model gebruikt? Nee, de modellen zijn identiek  </li> <li>Is er andere forcering gebruikt? De forcering(neerslag en verdamping is in 2021 niet opgeslagen, omdat de bestanden te groot waren. We kunnen dus niet met zekerheid zeggen dat de forcering gelijk is.  </li> <li>Zijn er andere software/processing scripts  gebruikt (hdsrhipy)? Het model wordt met dezelfde imodflow versie gedraaid. Wel is het Python environment van de originele run niet opgeslagen. Dit wordt gebruikt voor de pre en postprocessing van het model. </li> </ul>"},{"location":"resultaat_hydromedah/#vraag-3-levert-de-reproductie-betere-resultaten","title":"Vraag 3  Levert de reproductie betere resultaten?","text":"<p>Kwalitatief: De nieuwe resultaten zien er plausibeler uit dan de resultaten van 2021: Vreemd patroon in GXG kaarten, zie onderstaande GVG</p> <p></p> <p>Kwantitatief: De resultaten zien er  Op basis van code uit de validatie van het LHM: =&gt;127 metingen die geschikt zijn voor validatie</p> <p></p> <p>Kwantitatief scoort de huidige runbeter op de LHM toetsingscriteria (HKV, 2021), maar beide runs scoren een onvoldoende.</p> <p></p> <p>Kwantitatief: De vraag is of toetsing aan LHM criteria, in dit geval, zinnig is: </p> <ul> <li>Aantal validatie metingen beperkt (127) en liggen veelal in clusters; de punten zijn misschien niet zo representatief voor het hele gebied      </li> <li>Ruimtelijk beeld van de afwijking tussen beide modellen op validatiemeetpunten is gelijk bij GXG\u2019s; verschillen tussen de resultaten zijn klein; zie onderstaande figuren.  </li> <li>In Python notebook kun je de punten aanklikken en de exacte afwijking per punt zien.  </li> </ul> <p></p>"},{"location":"resultaat_hydromedah/#2-aanpassing-deklaagweerstand","title":"2 Aanpassing deklaagweerstand","text":"<p>De deklaagweerstand van LHM is in het algemeen veel lager dan de deklaagweerstand van Hydromedaha, zie de onderstaande figuren. Het effect op de GLG en GHG door lagere LHM deklaagweerstand is:  </p> <ul> <li>In infiltratiegebieden zakt de grondwaterstand (rode gebieden in figuren op volgende pagina)</li> <li>In drainagebieden stijgt de grondwaterstand (blauwe gebieden in figuren op volgende pagina)</li> <li>In de GLG zie je in drainagegebieden meer effect dan in de GHG. De grondwaterstand bij GHG is zo hoog, dat deze wordt afgetopt door de opgelegde drainagehoogte.</li> </ul> <p></p> <p>De aanpassing van de deklaagweerstand heeft een nihil effect op de statistiek van de LHM criteria.  </p>"},{"location":"resultaat_hydromedah/#3-aanpassing-peilenkaart","title":"3 Aanpassing peilenkaart","text":"<p>In het Python notebook vind je de stappen hoe de nieuwe peilen verwerkt zijn in het Hydromedah model - Winter en zomerpeil zijn in de nieuwe peilenkaart in veel gebieden lager. Dit is terug te zien in de GLG en GHG - Het effect van de aanpassing van de deklaagweerstand is groter dan de aanpassingen in de peilen - We gaan ervan uit dat deze nieuwe peilen niet representatief zijn voor de periode 2010-2020. Een vergelijking met metingen heeft daarmee geen zin</p> <p>In onderstaande figuen zie je verschilkaarten tussen respectievelijk het nieuwe winterpeil minus het Hydromedah winterpeil en het nieuwe zomerpeil minus het Hydromedah zomerpeil. Uit deze figuren blijkt dat de peilen over het algemeen verlaagd zijn. </p> <p></p>"},{"location":"resultaat_hydromedah/#4-gecombineerd-resultaat","title":"4 Gecombineerd resultaat","text":"<p>Het effect op GLG en GHG door de aanpassing van de peilen en de deklaagweerstand wordt gepresenteerd in onderstaande figuur. Hierna tonen we de grondwatertrappenkaarten voor het huidig modelresultaat en het gecombineerde modelresultaat (aangepaste peilen en deklaagweerstand LHM):</p> <p></p>"},{"location":"resultaat_hydromedah/#5-conclusies-en-aanbevelingen","title":"5 Conclusies en aanbevelingen","text":""},{"location":"resultaat_hydromedah/#51-conclusies","title":"5.1 Conclusies","text":"<ul> <li>De originele run die gedraaid is in 2021 verschilt van de huidige originele run. We weten vooralsnog niet waarom er een verschil is tussen beiden resultaten.</li> <li>Zowel de huidige originele run als de huidige basisrun met LHM deklaagweerstand als de originelerun in 2021 produceren resultaten die ruim slechter zijn dan de toetscriteria die opgesteld zijn voor het LHM. Kanttekening hierbij:     1) Er zijn slechts 127 metingen die geschikt zijn om te valideren.     2) De metingen liggen veelal in clusters in het HDSR gebied.   </li> <li>De deklaagweerstand van het LHM is in grote gebieden van het HDSR gebied vele malen kleiner dan de Hydromedah deklaagweerstand. Dit resulteert in een hogere grondwaterstand in de drainerende gebieden en een lagere grondwaterstand in de infiltratiegebieden</li> <li>Het peil van de waterlopen is aangepast mbv de nieuwe peilenkaart. In grote gebieden gaan de peilen omlaag wat ook te zien is in de GLG en GHG</li> </ul>"},{"location":"resultaat_hydromedah/#52-aanbevelingen","title":"5.2 Aanbevelingen","text":"<ul> <li>De originele run uit 2021 was niet te reproduceren. Dit kan in de toekomst alleen voorkomen worden door voldoende beheer en onderhoud op hdsrhipy, het model, de randvoorwaarden en de rekensoftware.</li> <li>Het model voldoet niet aan de toetscriteria van het LHM tav GHG en GLG. De vraag is hoeveel effect deze fout heeft op het TEO debiet. Dit kan, buiten de scope van deze opdracht, verder onderzocht worden door het vergelijken van gemeten en gesimuleerde afvoeren en afvoerstatistiek.</li> <li>Het basismodel was, voor zover wij kunnen overzien, niet eerder getoetst aan objectieve criteria. Wij bevelen aan zulke criteria op te stellen en te gebruiken voor toekomstige modelstudies.</li> </ul>"},{"location":"resultaat_hydromedah/#literatuur","title":"Literatuur:","text":"<p>HKV, Acacia water en Berendrecht consultancy (2021), \u201cValidatie en toetsing LHM 4.1\u201d, HKV rapport 4313.10, https://puc.overheid.nl/rijkswaterstaat/doc/PUC_640427_31/1/   </p>"},{"location":"updaten_hydromedah/","title":"Updaten Hydromedah","text":"In\u00a0[1]: Copied! <pre>try: # to bypass ImportError at rasterio.__init__ from rasterio.__version ....\n    import rasterio\nexcept ImportError:\n    from osgeo import gdal\n    import rasterio\n\nfrom dask import array # If you don't do this imod.idf.open() (version 0.9.0) will give an AttributeError: module 'dask' has no attribute 'array'\nimport geopandas as gpd\nimport imod\nimport numpy as np\nfrom pathlib import Path\nimport shutil\nfrom rasterio.features import rasterize\nfrom rasterio.fill import fillnodata\nimport xarray as xr\n\nfrom nhi_data import Ondergrond\n\nimport warnings\nwarnings.filterwarnings(\"ignore\") # To avoid logging RuntimeWarning in rasterio.fill.fillnodata\n</pre> try: # to bypass ImportError at rasterio.__init__ from rasterio.__version ....     import rasterio except ImportError:     from osgeo import gdal     import rasterio  from dask import array # If you don't do this imod.idf.open() (version 0.9.0) will give an AttributeError: module 'dask' has no attribute 'array' import geopandas as gpd import imod import numpy as np from pathlib import Path import shutil from rasterio.features import rasterize from rasterio.fill import fillnodata import xarray as xr  from nhi_data import Ondergrond  import warnings warnings.filterwarnings(\"ignore\") # To avoid logging RuntimeWarning in rasterio.fill.fillnodata In\u00a0[2]: Copied! <pre>oppervlaktewater_dir = Path(r\"d:\\projecten\\D2304.HDSR_TEO_debieten\\02.model\\data\\hydromedah\\oppervlaktewater\")\n\ntemplate_idf = oppervlaktewater_dir.joinpath(\"winter\", \"PEIL_LAAG1_1.IDF\")\ntemplate_da = imod.idf.open(template_idf)\n\nshape = template_da.shape\nheight, width = template_da.shape\ntransform = imod.util.transform(template_da)\n\n_, xmin, xmax, _, ymin, ymax = imod.util.spatial_reference(template_da)\n</pre> oppervlaktewater_dir = Path(r\"d:\\projecten\\D2304.HDSR_TEO_debieten\\02.model\\data\\hydromedah\\oppervlaktewater\")  template_idf = oppervlaktewater_dir.joinpath(\"winter\", \"PEIL_LAAG1_1.IDF\") template_da = imod.idf.open(template_idf)  shape = template_da.shape height, width = template_da.shape transform = imod.util.transform(template_da)  _, xmin, xmax, _, ymin, ymax = imod.util.spatial_reference(template_da) In\u00a0[3]: Copied! <pre>ondergrond = Ondergrond(bbox=(xmin,ymin,xmax,ymax))\nlayer = ondergrond.get_layers(filter=\"resistance_layer1\")[0]\nprint(layer)\n</pre> ondergrond = Ondergrond(bbox=(xmin,ymin,xmax,ymax)) layer = ondergrond.get_layers(filter=\"resistance_layer1\")[0] print(layer) <pre>ondergrond2:vertical_resistance_layer1_lhm41\n</pre> In\u00a0[4]: Copied! <pre>ondergrond.download_layer(layer, \"vertical_resistance_layer1.tif\")\nondergrond.download_layer(layer, \"vertical_resistance_layer1.idf\")\n</pre> ondergrond.download_layer(layer, \"vertical_resistance_layer1.tif\") ondergrond.download_layer(layer, \"vertical_resistance_layer1.idf\") In\u00a0[5]: Copied! <pre>peilengebieden_gdf = gpd.read_file(\"Peilgebieden.geojson\", engine=\"pyogrio\")\npeilengebieden_gdf.explore()\n</pre> peilengebieden_gdf = gpd.read_file(\"Peilgebieden.geojson\", engine=\"pyogrio\") peilengebieden_gdf.explore() Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[6]: Copied! <pre>peilen_gdf = gpd.GeoDataFrame(peilengebieden_gdf[\"geometry\"])\npeilen_gdf.to_crs(28992, inplace=True)\npeilen_gdf[\"soort_streefpeil\"] = peilengebieden_gdf[\"SOORTSTREEFPEIL\"]\npeilen_gdf[\"code\"] = peilengebieden_gdf[\"CODE\"]\npeilen_gdf[\"nodata\"] = False\n</pre> peilen_gdf = gpd.GeoDataFrame(peilengebieden_gdf[\"geometry\"]) peilen_gdf.to_crs(28992, inplace=True) peilen_gdf[\"soort_streefpeil\"] = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] peilen_gdf[\"code\"] = peilengebieden_gdf[\"CODE\"] peilen_gdf[\"nodata\"] = False In\u00a0[7]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 1\n\n# VASTPEIL = -999 komt voor, dit maskeren we en leggen we vast als no data\ndata_mask = (peilengebieden_gdf[\"VASTPEIL\"] != -999) &amp; ~peilengebieden_gdf[\"VASTPEIL\"].isna()\npeilen_gdf.loc[(peil_mask &amp;  ~data_mask), [\"nodata\"]] = True\n\n# vullen zomerpeil en winterpeil\npeilen_gdf.loc[(peil_mask &amp; data_mask), [\"zomerpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"]\npeilen_gdf.loc[(peil_mask &amp; data_mask), [\"winterpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"]\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 1  # VASTPEIL = -999 komt voor, dit maskeren we en leggen we vast als no data data_mask = (peilengebieden_gdf[\"VASTPEIL\"] != -999) &amp; ~peilengebieden_gdf[\"VASTPEIL\"].isna() peilen_gdf.loc[(peil_mask &amp;  ~data_mask), [\"nodata\"]] = True  # vullen zomerpeil en winterpeil peilen_gdf.loc[(peil_mask &amp; data_mask), [\"zomerpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"] peilen_gdf.loc[(peil_mask &amp; data_mask), [\"winterpeil\"]] = peilengebieden_gdf[(peil_mask &amp; data_mask)][\"VASTPEIL\"] In\u00a0[8]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 2\n\n# bij -999 in bovenpeil stellen we bovenpeil gelijk aan onderpeil\nnodata_mask = peil_mask &amp; (peilengebieden_gdf[\"BOVENPEIL\"] == -999)\npeilengebieden_gdf.loc[nodata_mask, [\"BOVENPEIL\"]] = peilengebieden_gdf[nodata_mask][\"ONDERPEIL\"]\n\n# bij -999 in onderpeil stellen we onderpeil gelijk aan bovenpeil\nnodata_mask = peil_mask &amp; (peilengebieden_gdf[\"ONDERPEIL\"] == -999)\npeilengebieden_gdf.loc[nodata_mask, [\"ONDERPEIL\"]] = peilengebieden_gdf[nodata_mask][\"BOVENPEIL\"]\n\npeilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = (peilengebieden_gdf[peil_mask][\"ONDERPEIL\"] + peilengebieden_gdf[peil_mask][\"BOVENPEIL\"]) / 2\npeilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilen_gdf[peil_mask][\"zomerpeil\"]\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 2  # bij -999 in bovenpeil stellen we bovenpeil gelijk aan onderpeil nodata_mask = peil_mask &amp; (peilengebieden_gdf[\"BOVENPEIL\"] == -999) peilengebieden_gdf.loc[nodata_mask, [\"BOVENPEIL\"]] = peilengebieden_gdf[nodata_mask][\"ONDERPEIL\"]  # bij -999 in onderpeil stellen we onderpeil gelijk aan bovenpeil nodata_mask = peil_mask &amp; (peilengebieden_gdf[\"ONDERPEIL\"] == -999) peilengebieden_gdf.loc[nodata_mask, [\"ONDERPEIL\"]] = peilengebieden_gdf[nodata_mask][\"BOVENPEIL\"]  peilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = (peilengebieden_gdf[peil_mask][\"ONDERPEIL\"] + peilengebieden_gdf[peil_mask][\"BOVENPEIL\"]) / 2 peilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilen_gdf[peil_mask][\"zomerpeil\"] In\u00a0[9]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 3\n\npeilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = peilengebieden_gdf[peil_mask][\"ZOMERPEIL\"]\npeilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilengebieden_gdf[peil_mask][\"WINTERPEIL\"]\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] == 3  peilen_gdf.loc[peil_mask, [\"zomerpeil\"]] = peilengebieden_gdf[peil_mask][\"ZOMERPEIL\"] peilen_gdf.loc[peil_mask, [\"winterpeil\"]] = peilengebieden_gdf[peil_mask][\"WINTERPEIL\"] In\u00a0[10]: Copied! <pre>peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] &gt;= 4\npeilen_gdf.loc[peil_mask, [\"nodata\"]] = True\n</pre> peil_mask = peilengebieden_gdf[\"SOORTSTREEFPEIL\"] &gt;= 4 peilen_gdf.loc[peil_mask, [\"nodata\"]] = True In\u00a0[11]: Copied! <pre>data_mask = ~peilen_gdf[\"nodata\"]\npeilen_gdf.loc[data_mask, [\"peil_betrouwbaar\"]] =  peilen_gdf[data_mask][\"winterpeil\"] &lt;= peilen_gdf[data_mask][\"zomerpeil\"]\n</pre> data_mask = ~peilen_gdf[\"nodata\"] peilen_gdf.loc[data_mask, [\"peil_betrouwbaar\"]] =  peilen_gdf[data_mask][\"winterpeil\"] &lt;= peilen_gdf[data_mask][\"zomerpeil\"] In\u00a0[12]: Copied! <pre>peilen_gdf.to_file(\"peilen.gpkg\")\n</pre> peilen_gdf.to_file(\"peilen.gpkg\") In\u00a0[13]: Copied! <pre>crs = peilen_gdf.crs\n\nprofile={ # profiel voor GeoTifs\n    \"driver\": \"GTiff\",\n    \"dtype\":rasterio.dtypes.float32,\n    \"nodata\": -999,\n    \"width\" :width,\n    \"height\": height,\n    \"count\": 1,\n    \"crs\": crs,\n    \"transform\": transform}\n</pre> crs = peilen_gdf.crs  profile={ # profiel voor GeoTifs     \"driver\": \"GTiff\",     \"dtype\":rasterio.dtypes.float32,     \"nodata\": -999,     \"width\" :width,     \"height\": height,     \"count\": 1,     \"crs\": crs,     \"transform\": transform} In\u00a0[14]: Copied! <pre>shapes = (\n    (geom, 1)\n    for geom in peilen_gdf[~peilen_gdf[\"code\"].isin([\"PG2179\", \"PG2112\"])][\"geometry\"]\n    )\n\nmask_array = rasterize(\n    shapes=shapes,\n    out_shape=shape,\n    transform=transform,\n    all_touched=True)\n\nwith rasterio.open(\"mask.tif\", \"w+\", **profile) as dst:\n    dst.write(mask_array, 1)\n</pre> shapes = (     (geom, 1)     for geom in peilen_gdf[~peilen_gdf[\"code\"].isin([\"PG2179\", \"PG2112\"])][\"geometry\"]     )  mask_array = rasterize(     shapes=shapes,     out_shape=shape,     transform=transform,     all_touched=True)  with rasterio.open(\"mask.tif\", \"w+\", **profile) as dst:     dst.write(mask_array, 1) In\u00a0[15]: Copied! <pre>for seizoen in [\"zomer\", \"winter\"]:\n    # 1. Verrasteren van de zomer en winterpeilen waar deze data bevatten. We schrijven deze weg in `zomerpeil_origineel.tif` en `winterpeil_origineel.tif`\n    shapes = (\n        (geom, value)\n        for geom, value in zip(peilen_gdf[~peilen_gdf.nodata][\"geometry\"], peilen_gdf[~peilen_gdf.nodata][f\"{seizoen}peil\"])\n        )\n    \n    peil_array = rasterize(\n        shapes=shapes,\n        out_shape=shape,\n        fill=-999,\n        transform=transform,\n        all_touched=False)\n    \n    with rasterio.open(f\"{seizoen}peil_ruw.tif\", \"w+\", **profile) as dst:\n        dst.write(peil_array, 1)\n\n    # 2. Het opvullen van `nodata` cellen binnen het mask door middel van interpolatie. We schrijven deze weg als `zomerpeil.tif` en `winterpeil.tif\n    mask = np.where((peil_array == -999) &amp; (mask_array == 1), 0, 1)\n    mask = np.where(mask_array == 0, np.NaN, mask)\n    peil_array = fillnodata(\n        peil_array,\n        mask=mask,\n        max_search_distance=20,\n        smoothing_iterations=0\n        )\n    \n    peil_array = np.where(mask_array == 1, peil_array, -999)\n    with rasterio.open(f\"{seizoen}peil.tif\", \"w+\", **profile) as dst:\n        dst.write(peil_array, 1)\n    \n    dataset = imod.rasterio.open(f\"{seizoen}peil.tif\")\n    imod.idf.save(f\"{seizoen}peil\", dataset)\n\n    # 3. Het overschrijven van de waarden in alle `PEIL_LAAG*.IDF` bestanden\n    out_dir = Path(seizoen)\n    if out_dir.exists():\n        shutil.rmtree(out_dir)\n    out_dir.mkdir()\n    datasets = imod.idf.open_dataset(oppervlaktewater_dir.joinpath(seizoen,\"PEIL_LAAG*.IDF\"))\n    \n    for laag, peil_da in datasets.items():\n\n        # - `nodata` in de oorspronkelijke peilen blijft `nodata`in de nieuwe peilen\n        peil_da = xr.where(\n            np.isnan(peil_da),\n            peil_da,\n            np.where(peil_array == -999, peil_da, peil_array)\n            )\n        \n        # - Wanneer er een er een bodemhoogte is wordt het nieuwe peil gelijk of hoger dan de bodemhoogte\n        bodemhoogte_name = f\"BODEMHOOGTE_LAAG{laag[len(laag)-3:]}\"\n        bodemhoogte_da = imod.idf.open(\n            oppervlaktewater_dir.joinpath(seizoen,f\"{bodemhoogte_name}.IDF\")\n            )\n        peil_da = xr.where(\n            np.isnan(peil_da),\n            peil_da,\n            xr.where(\n                np.isnan(bodemhoogte_da),\n                peil_da,\n                xr.where(\n                    bodemhoogte_da &lt; peil_da,\n                    peil_da,\n                    bodemhoogte_da\n                    ) # zowel bodemhoogte als peil zijn niet NaN\n                )\n            )\n        # Wegschrijven IDF\n        imod.idf.write(out_dir / f\"{laag}.idf\", peil_da)\n</pre> for seizoen in [\"zomer\", \"winter\"]:     # 1. Verrasteren van de zomer en winterpeilen waar deze data bevatten. We schrijven deze weg in `zomerpeil_origineel.tif` en `winterpeil_origineel.tif`     shapes = (         (geom, value)         for geom, value in zip(peilen_gdf[~peilen_gdf.nodata][\"geometry\"], peilen_gdf[~peilen_gdf.nodata][f\"{seizoen}peil\"])         )          peil_array = rasterize(         shapes=shapes,         out_shape=shape,         fill=-999,         transform=transform,         all_touched=False)          with rasterio.open(f\"{seizoen}peil_ruw.tif\", \"w+\", **profile) as dst:         dst.write(peil_array, 1)      # 2. Het opvullen van `nodata` cellen binnen het mask door middel van interpolatie. We schrijven deze weg als `zomerpeil.tif` en `winterpeil.tif     mask = np.where((peil_array == -999) &amp; (mask_array == 1), 0, 1)     mask = np.where(mask_array == 0, np.NaN, mask)     peil_array = fillnodata(         peil_array,         mask=mask,         max_search_distance=20,         smoothing_iterations=0         )          peil_array = np.where(mask_array == 1, peil_array, -999)     with rasterio.open(f\"{seizoen}peil.tif\", \"w+\", **profile) as dst:         dst.write(peil_array, 1)          dataset = imod.rasterio.open(f\"{seizoen}peil.tif\")     imod.idf.save(f\"{seizoen}peil\", dataset)      # 3. Het overschrijven van de waarden in alle `PEIL_LAAG*.IDF` bestanden     out_dir = Path(seizoen)     if out_dir.exists():         shutil.rmtree(out_dir)     out_dir.mkdir()     datasets = imod.idf.open_dataset(oppervlaktewater_dir.joinpath(seizoen,\"PEIL_LAAG*.IDF\"))          for laag, peil_da in datasets.items():          # - `nodata` in de oorspronkelijke peilen blijft `nodata`in de nieuwe peilen         peil_da = xr.where(             np.isnan(peil_da),             peil_da,             np.where(peil_array == -999, peil_da, peil_array)             )                  # - Wanneer er een er een bodemhoogte is wordt het nieuwe peil gelijk of hoger dan de bodemhoogte         bodemhoogte_name = f\"BODEMHOOGTE_LAAG{laag[len(laag)-3:]}\"         bodemhoogte_da = imod.idf.open(             oppervlaktewater_dir.joinpath(seizoen,f\"{bodemhoogte_name}.IDF\")             )         peil_da = xr.where(             np.isnan(peil_da),             peil_da,             xr.where(                 np.isnan(bodemhoogte_da),                 peil_da,                 xr.where(                     bodemhoogte_da &lt; peil_da,                     peil_da,                     bodemhoogte_da                     ) # zowel bodemhoogte als peil zijn niet NaN                 )             )         # Wegschrijven IDF         imod.idf.write(out_dir / f\"{laag}.idf\", peil_da)"},{"location":"updaten_hydromedah/#updaten-hydromedah","title":"Updaten Hydromedah\u00b6","text":"<p>Met deze Notebook genereren we de volgende output:</p> <ul> <li><code>vertical_resistance_layer1</code>: een nieuwe verticale weerstand voor de deklaag</li> <li><code>winter\\peil_laag#_#.idf</code>: nieuwe peilen voor de winter in de verschillende (sub) lagen</li> <li><code>zomer\\peil_laag#_#.idf</code>: nieuwe peilen voor de zomer in de verschillende (sub) lagen</li> </ul> <p>Een aantal relevante tussenproducten:</p> <ul> <li><code>peilen.gpkg</code>: de geaggregeerde vaste/zomer/winter en flexibele peilen naar 1 zomer en 1 winterpeil, wanneer deze kan worden berekend</li> <li><code>winterpeil_ruw.tif</code>, <code>winterpeil.tif</code>, <code>winterpeil.idf</code>: het ruwe en geinterpoleerde resultaat van de verrastering van de kolom <code>winterpeil</code> in <code>peilen.gpkg</code></li> <li><code>zomerpeil_ruw.tif</code>, <code>zomerpeil.tif</code>, <code>zomerpeil.idf</code>: het ruwe en geinterpoleerde resultaat van de verrastering van de kolom <code>zomerpeil</code> in <code>peilen.gpkg</code></li> </ul> <p>In deze Notebook worden alle tussen en eindproducten stap-voor-stap gegenereerd met duiding en Python-code.</p>"},{"location":"updaten_hydromedah/#specificaties-imodflow-inlezen","title":"Specificaties iMODFLOW inlezen\u00b6","text":"<p>We lezen de specificatie van het iMODFLOW model in. We gebruiken daarvoor de laag <code>PEIL_LAAG1_1.IDF</code>, waarvan we de ruimtelijke attributen overnemen.</p>"},{"location":"updaten_hydromedah/#vervangen-deklaagweerstand","title":"Vervangen deklaagweerstand\u00b6","text":"<p>Hier vervangen we de verticale weerstand van de deklaag uit het LHM4.1</p>"},{"location":"updaten_hydromedah/#inladen-nhi-ondergrond","title":"Inladen NHI ondergrond\u00b6","text":"<p>We maken een Ondergrond-object, voor de bounding-box van het HDSR MODFLOW model. We zoeken de juiste laag op de NHI-geoserver</p>"},{"location":"updaten_hydromedah/#download-en-conversie-naar-geotiff-en-idf","title":"Download en conversie naar GeoTIFF en IDF\u00b6","text":"<p>Met dit object kunnen we de laag downloaden en opslaan als GeoTiff en IDF</p>"},{"location":"updaten_hydromedah/#vervangen-peil-en-peilgebieden","title":"Vervangen peil en peilgebieden\u00b6","text":"<p>Hier vervangen we de oppervlaktewaterpeilen van het iMODFLOW model</p>"},{"location":"updaten_hydromedah/#inladen-peilgebieden","title":"Inladen peilgebieden\u00b6","text":"<p>De peilgebieden zijn op 04-07-2023 gedownload (gegenereerd op 23 jun 2023 11:04) via de HDSR Infovijver als GeoJSON.</p>"},{"location":"updaten_hydromedah/#aggregeren-peilen-naar-zomer-en-winterpeil","title":"Aggregeren peilen naar zomer- en winterpeil\u00b6","text":"<p>We lezen de geometrieen in van de peilgebieden en kopieren het attribuut <code>SOORTSTREEFPEIL</code> (<code>soort_streefpeil</code>) met de volgende enumeratie:</p> <ul> <li><code>1</code>: vast peil</li> <li><code>2</code>: flexibel peil</li> <li><code>3</code>: zomer- en winterpeil</li> <li><code>4</code>, <code>5</code>, <code>99</code>: geen peil vastgesteld/peil onbekend</li> </ul> <p>We willen de volgende kolommen vullen:</p> <ul> <li><code>code</code>: waterschapscode</li> <li><code>nodata</code>: geen zomer- winterpeil bekend = <code>True</code>, anders <code>False</code></li> <li><code>betrouwbaar_peil</code>: <code>winterpeil</code> &lt;= <code>zomerpeil</code> = <code>True</code>, anders <code>False</code></li> <li><code>zomerpeil</code></li> <li><code>winterpeil</code></li> </ul> <p>We projecteren de geometri\u00ebn naar Rijksdriehoekstelsel (epsg 28992) en vullen de kolommen <code>soort_streefpeil</code>, <code>code</code> uit de oorspronkelijke data en zetten de waarden van de kolom <code>nodata</code> op <code>False</code>.</p>"},{"location":"updaten_hydromedah/#vast-peil","title":"Vast Peil\u00b6","text":"<p>Wanneer <code>VASTPEIL</code> == -999 of niet ingevuld, dan geven we dit aan in <code>nodata</code>. Voor de peilgebieden waarvan gegevens bekend zijn geldt <code>zomerpeil</code> = <code>winterpeil</code> = <code>vastpeil</code></p>"},{"location":"updaten_hydromedah/#flexibel-peil","title":"Flexibel peil\u00b6","text":"<p>In zowel <code>ONDERPEIL</code> als <code>BOVENPEIL</code> komt -999 voor, maar niet gelijktijdig. In deze gevallen stellen we <code>ONDERPEIL</code> gelijk aan <code>BOVENPEIL</code> of vise-versa. Vervolgens brekenen we <code>zomerpeil</code> en <code>winterpeil</code>:</p> <pre><code>zomerpeil = winterpeil = (ONDERPEIL + BOVENPEIL) / 2\n</code></pre>"},{"location":"updaten_hydromedah/#zomer-en-winterpeil","title":"Zomer- en winterpeil\u00b6","text":"<p>Hier komen geen ontbrekende, danwel -999 waarden voor, dus deze nemen we direct over</p>"},{"location":"updaten_hydromedah/#onbrekende-peilen","title":"Onbrekende peilen\u00b6","text":"<p>Wanneer peilen ontbreken, geven we dat aan door <code>nodata</code> op <code>True</code> te zetten</p>"},{"location":"updaten_hydromedah/#indicatie-betrouwbaarheid","title":"Indicatie betrouwbaarheid\u00b6","text":"<p>Voor alle gebieden met <code>zomerpeil</code> en <code>winterpeil</code> controleren we of <code>winterpeil</code> kleiner of gelijk aan <code>zomerpeil</code> is.</p>"},{"location":"updaten_hydromedah/#wegschrijven","title":"Wegschrijven\u00b6","text":""},{"location":"updaten_hydromedah/#conversie-naar-imod","title":"Conversie naar imod\u00b6","text":"<p>Het resultaat in <code>peilen_gdf</code> wordt weggeschreven naar idf-bestanden. Van de verrasterde peilen schrijven we tevens GeoTifs weg, zodat deze in GIS kunnen worden geladen.</p>"},{"location":"updaten_hydromedah/#data-mask","title":"Data mask\u00b6","text":"<p>We zorgen dat de Utrechtse Heuvelrug (<code>PG2179</code>) en Nederrijn en Lek (<code>PG2112</code>) uit de peilen-rasters blijven. We houden daar de oorspronkelijke waarden. Het deel waar we peilen voor verrasteren schrijven we weg als <code>mask.tif</code>.</p>"},{"location":"updaten_hydromedah/#verwerking-in-idfs","title":"Verwerking in IDFs\u00b6","text":"<p>Voor de seizoenen <code>zomer</code> en <code>winter</code> voeren we de volgende stappen uit:</p> <ol> <li>Verrasteren van de zomer en winterpeilen waar deze data bevatten. We schrijven deze weg in <code>zomerpeil_ruw.tif</code> en <code>winterpeil_ruw.tif</code></li> <li>Het opvullen van <code>nodata</code> cellen binnen het mask door middel van interpolatie. We schrijven deze weg als <code>zomerpeil.tif</code> en <code>winterpeil.tif</code></li> <li>Het overschrijven van de waarden in alle <code>PEIL_LAAG*.IDF</code> bestanden uit het oorsprokelijke model met de regels:<ul> <li><code>nodata</code> in de oorspronkelijke peilen blijft <code>nodata</code>in de nieuwe peilen</li> <li>Wanneer er een er een bodemhoogte is wordt het nieuwe peil gelijk of hoger dan de bodemhoogte</li> </ul> </li> </ol>"},{"location":"vergelijking_laterals/","title":"Vergelijking lateralen","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n\n# De locatie waar de informatieproducten worden geplaastst.\nexport_path = Path('../results')\n</pre> from pathlib import Path import pandas as pd import matplotlib.pyplot as plt  %matplotlib inline  # De locatie waar de informatieproducten worden geplaastst. export_path = Path('../results') In\u00a0[2]: Copied! <pre># inlezen csv met het origineel uit 2021\ndf_origineel = pd.read_csv(\n    export_path.joinpath(r\"geleverd_Ruud\\Maatgevend\\laterale_flux\\Laterals_Huidig250.csv\"),\n    index_col=0,\n)\ndf_origineel.index = pd.to_datetime(df_origineel.index) # Index naar datetime\ndf_origineel.drop(labels=[\"0\"], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg\n\n# inlezen csv met nieuwe run en hetzelde model\ndf_huidig = pd.read_csv(\n    export_path.joinpath(r\"Maatgevend\\laterals_Huidig250.csv\"),\n    index_col=0,\n)\ndf_huidig.index = pd.to_datetime(df_huidig.index) # Index naar datetime\ndf_huidig.drop(labels=['0'], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg\n</pre> # inlezen csv met het origineel uit 2021 df_origineel = pd.read_csv(     export_path.joinpath(r\"geleverd_Ruud\\Maatgevend\\laterale_flux\\Laterals_Huidig250.csv\"),     index_col=0, ) df_origineel.index = pd.to_datetime(df_origineel.index) # Index naar datetime df_origineel.drop(labels=[\"0\"], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg  # inlezen csv met nieuwe run en hetzelde model df_huidig = pd.read_csv(     export_path.joinpath(r\"Maatgevend\\laterals_Huidig250.csv\"),     index_col=0, ) df_huidig.index = pd.to_datetime(df_huidig.index) # Index naar datetime df_huidig.drop(labels=['0'], axis=1, inplace=True) # de eerste kolom is leeg, dus gooien we weg In\u00a0[3]: Copied! <pre>df_origineel[\"1727\"].plot()\n</pre> df_origineel[\"1727\"].plot() Out[3]: <pre>&lt;AxesSubplot:&gt;</pre> In\u00a0[4]: Copied! <pre>df_origineel.drop(labels=[\"1727\"], axis=1, inplace=True)\ndf_huidig.drop(labels=[\"1727\"], axis=1, inplace=True)\n</pre> df_origineel.drop(labels=[\"1727\"], axis=1, inplace=True) df_huidig.drop(labels=[\"1727\"], axis=1, inplace=True) In\u00a0[5]: Copied! <pre>series_origineel = df_origineel.sum(axis=1)\nseries_huidig = df_huidig.sum(axis=1)\n</pre> series_origineel = df_origineel.sum(axis=1) series_huidig = df_huidig.sum(axis=1) In\u00a0[6]: Copied! <pre>def grafiek(series_origineel, series_huidig, y_label, figsize=(12, 6)):\n    \n    \n    years = pd.date_range(start=\"2010-07-01\", end=\"2021-07-01\", freq=\"AS-JUL\")\n    plt.figure(figsize=figsize) #setten van de grootte van de figuur\n\n    # Plotten van de data\n    plt.plot(series_origineel, label=\"origineel\")\n    plt.plot(series_huidig, label=\"huidig\")\n\n    # Grafiek opmaken\n    plt.xlabel(\"Tijd\")\n    plt.ylabel(y_label)\n    plt.legend()\n    plt.grid(True)\n    plt.xlim(\"2010-07-01\", \"2021-06-30\")\n    plt.xticks(years, years.strftime('%Y-%m-%d'), rotation=90)\n    \n    # Tonen\n    plt.show()\n</pre> def grafiek(series_origineel, series_huidig, y_label, figsize=(12, 6)):               years = pd.date_range(start=\"2010-07-01\", end=\"2021-07-01\", freq=\"AS-JUL\")     plt.figure(figsize=figsize) #setten van de grootte van de figuur      # Plotten van de data     plt.plot(series_origineel, label=\"origineel\")     plt.plot(series_huidig, label=\"huidig\")      # Grafiek opmaken     plt.xlabel(\"Tijd\")     plt.ylabel(y_label)     plt.legend()     plt.grid(True)     plt.xlim(\"2010-07-01\", \"2021-06-30\")     plt.xticks(years, years.strftime('%Y-%m-%d'), rotation=90)          # Tonen     plt.show() In\u00a0[7]: Copied! <pre>grafiek(\n    series_origineel, series_huidig,\n    \"Debiet naar watersysteem [m3/s]\"\n)\n</pre> grafiek(     series_origineel, series_huidig,     \"Debiet naar watersysteem [m3/s]\" ) In\u00a0[8]: Copied! <pre>hdsr_area_m2 = 830210666 # berekend uit waterschapsgrenzen shapefile (in rijksdriehoekstelsel)\n\n# van seconden naar (x 86400) dag, van m3 naar m (/ oppervlak HDSR) en van m naar mm (x 1000)\nseries_origineel_mm = ((series_origineel * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30']\nseries_huidig_mm = ((series_huidig * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30']\n\n# plotten van de grafieken\ngrafiek(\n    series_origineel_mm.loc['2010-07-01':'2021-07-01'].cumsum(),\n    series_huidig_mm.loc['2010-07-01':'2021-07-01'].cumsum(),\n    \"Cumulatief naar watersysteem [mm]\"\n)\n</pre> hdsr_area_m2 = 830210666 # berekend uit waterschapsgrenzen shapefile (in rijksdriehoekstelsel)  # van seconden naar (x 86400) dag, van m3 naar m (/ oppervlak HDSR) en van m naar mm (x 1000) series_origineel_mm = ((series_origineel * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30'] series_huidig_mm = ((series_huidig * 86400 * 1000) / hdsr_area_m2).loc['2010-07-01':'2021-06-30']  # plotten van de grafieken grafiek(     series_origineel_mm.loc['2010-07-01':'2021-07-01'].cumsum(),     series_huidig_mm.loc['2010-07-01':'2021-07-01'].cumsum(),     \"Cumulatief naar watersysteem [mm]\" ) In\u00a0[9]: Copied! <pre>def custom_year_grouping(series):\n    year = series.index.year\n    month = series.index.month\n    custom_year = year + (month &gt;= 7)\n    return custom_year\n\ngrafiek(\n    series_origineel_mm.groupby(custom_year_grouping(series_origineel_mm)).apply(lambda x: x.cumsum()),\n    series_huidig_mm.groupby(custom_year_grouping(series_huidig_mm)).apply(lambda x: x.cumsum()),\n    \"Cumulatief per jaar naar watersysteem [mm]\"\n)\n</pre> def custom_year_grouping(series):     year = series.index.year     month = series.index.month     custom_year = year + (month &gt;= 7)     return custom_year  grafiek(     series_origineel_mm.groupby(custom_year_grouping(series_origineel_mm)).apply(lambda x: x.cumsum()),     series_huidig_mm.groupby(custom_year_grouping(series_huidig_mm)).apply(lambda x: x.cumsum()),     \"Cumulatief per jaar naar watersysteem [mm]\" )"},{"location":"vergelijking_laterals/#vergelijking-lateralen","title":"Vergelijking lateralen\u00b6","text":"<p>Met deze notebook vergelijken we de lateralen uit de resultaten van het model geleverd in 2021 (<code>origineel</code>) met de resultaten van hetzelfde model in dit project (<code>huidig</code>)</p>"},{"location":"vergelijking_laterals/#1-voorbereiding","title":"1. Voorbereiding\u00b6","text":"<p>We lezen alle modules en paden in</p>"},{"location":"vergelijking_laterals/#2-inlezen","title":"2. Inlezen\u00b6","text":"<p>We lezen de csvs met laterale debieten in</p>"},{"location":"vergelijking_laterals/#21-inlezen","title":"2.1. Inlezen\u00b6","text":"<p>Hieronder lezen we de CSV's in</p>"},{"location":"vergelijking_laterals/#22-filteren-lateral-1727","title":"2.2. Filteren lateral 1727\u00b6","text":"<p>Op de Utrechtse heuvelrug zit een lateraal die 18.25 m3/s onttrekt uit het oppervlaktewatersysteem. In verhouding, op het de hele oppervlakte van HDSR (+/- 83000 ha) ongeveer 2mm/dag (ongeveer 700 mm/jaar).</p>"},{"location":"vergelijking_laterals/#3-sommeren-naar-hdsr","title":"3. Sommeren naar HDSR\u00b6","text":"<p>We sommeren de debieten naar het hele beheergebied van HDSR</p>"},{"location":"vergelijking_laterals/#3-plotten","title":"3. Plotten\u00b6","text":"<p>We maken plotjes om de verschillen inzichtelijk te maken</p>"},{"location":"vergelijking_laterals/#32-tijdseries","title":"3.2 Tijdseries\u00b6","text":"<p>We tonen de gesommeerde tijdreeksen.</p>"},{"location":"vergelijking_laterals/#32-tijdseries-cumulatief-over-tijd","title":"3.2 Tijdseries cumulatief over tijd\u00b6","text":"<p>We transformeren de data naar mm/dag en berekenen de cumulatieve onttrekking uit het watersysteem.</p>"},{"location":"vergelijking_laterals/#32-tijdseries-cumulatief-over-tijd-per-jaar","title":"3.2 Tijdseries cumulatief over tijd, per jaar\u00b6","text":"<p>We transformeren de data naar mm/dag en berekenen de cumulatieve onttrekking uit het watersysteem per jaar, waarbij we starten op 01/07 van elk jaar.</p>"}]}